#!/usr/bin/python3

from ortools.linear_solver import pywraplp
import mip
import gurobipy as gp

import numpy as np
import re
import sys
import json

import argparse

def build_OR_Tools_model(A, b, c, n, var_range, row_range, leq_constraints, 
geq_constraints, var_type, obj_type, ub_inputs, lb_inputs, params):
    # Create the solver object and the infinity value:
    solver = pywraplp.Solver.CreateSolver(params["SOLVER_NAME"])
    infinity = solver.infinity()

    # Processing the upper and lower bounds using the OR-Tools infinity:
    if(isinstance(ub_inputs, np.ndarray)):
        if(len(ub_inputs) != n):
            raise RuntimeError('Shape of ub array is incompatible with problem size!')
    elif(isinstance(ub_inputs, float)):
        ub_inputs = np.full(n, ub_inputs)
    else:
        ub_inputs = np.full(n, infinity)

    if(isinstance(lb_inputs, np.ndarray)):
        if(len(lb_inputs) != n):
            raise RuntimeError('Shape of lb array is incompatible with problem size!')
    elif(isinstance(lb_inputs, float)):
        lb_inputs = np.full(n, lb_inputs)
    else:
        lb_inputs = np.full(n, 0.0)

    # Creating the variables:
    x = dict()
    for j in var_range:
        if(var_type[j] == 'real'):
            x[j] = solver.NumVar(lb_inputs[j-1], ub_inputs[j-1], 'x[{}]'.format(j))
        elif(var_type[j] == 'binary'):
            x[j] = solver.BoolVar('x[{}]'.format(j))
        else:
            x[j] = solver.IntVar(lb_inputs[j-1], ub_inputs[j-1], 'x[{}]'.format(j))

    # Objective Function
    if(obj_type == '*EMPTY*'):
        obj_type = 'min'
    if(obj_type == 'min'):
        obj = solver.Minimize(sum(c[j] * x[j] for j in var_range))
    elif(obj_type == 'max'):
        obj = solver.Maximize(sum(c[j] * x[j] for j in var_range))
    else:
        raise RuntimeError('Problem in the objective function type input!')

    # Adding the constraints sets:
    cstr = dict()
    if(leq_constraints == '*'):
        cstr.update({'leq_{}'.format(i): solver.Add(sum(A[i, j] * x[j] for j in var_range) <= b[i]) for i in row_range})
    else:
        cstr.update({'leq_{}'.format(i): solver.Add(sum(A[i, j] * x[j] for j in var_range) <= b[i]) for i in leq_constraints})

    if(geq_constraints == '*'):
        cstr.update({'geq_{}'.format(i): solver.Add(sum(A[i, j] * x[j] for j in var_range) >= b[i]) for i in row_range})
    else:
        cstr.update({'geq_{}'.format(i): solver.Add(sum(A[i, j] * x[j] for j in var_range) >= b[i]) for i in geq_constraints})

    if(leq_constraints != '*' and geq_constraints != '*'):
        eq_constraints = set(row_range).difference(set(leq_constraints).union(set(geq_constraints)))
        cstr.update({'eq_{}'.format(i): solver.Add(sum(A[i, j] * x[j] for j in var_range) == b[i]) for i in eq_constraints})

    return solver, x, obj, cstr

def solve_OR_Tools_model(solver, params):
    # Solving the problem and printing results:
    if(params["TOTAL_SOLVING_TIME"] > 0):
        solver.set_time_limit(params["TOTAL_SOLVING_TIME"] * 1000)
    if(params["PRINT_SOLUTION_LOG"]):
        solver.EnableOutput()
    solver.SetNumThreads(params["NUM_THREADS"])
    if(params["RELATIVE_MIP_GAP_VALUE"] > 0):
        solverParams = pywraplp.MPSolverParameters()
        solverParams.SetDoubleParam(solverParams.RELATIVE_MIP_GAP, params["RELATIVE_MIP_GAP_VALUE"])
        status = solver.Solve(solverParams)
    else:
        status = solver.Solve()

    return status

def print_OR_Tools_solution(solver, status, params):
    print('Variables defined: [ ')
    print('    ', end='')
    for var in solver.variables():
        print(f'{var.name()}', end=' ')
    print('\n]')

    if(solver.Objective().minimization()):
        obj_type = 'MIN'
    elif(solver.Objective().maximization()):
        obj_type = 'MAX'
    else:
        raise RuntimeError('Problem in printing the objective function type!')

    print('Objective function being considered: {}'.format(obj_type.upper()))
    if((status == solver.FEASIBLE) or (status == solver.OPTIMAL)):
        ObjVal = solver.Objective().Value()
        print('Objective found with value: {}'.format(round(ObjVal, params["DIGITS_ON_SOLUTION"])))
        if(status == solver.FEASIBLE):
            print('The solution found is FEASIBLE!')
        else:
            print('The solution found is OPTIMAL!')
        print('Variables values:')
        if(params["PRINT_ZERO_VARS"]):
            for var in solver.variables():
                print('{} = {}'.format(var.name(), round(var.solution_value(), params["DIGITS_ON_SOLUTION"])))
        else:
            for var in solver.variables():
                if(var.solution_value() != 0):
                    print('{} = {}'.format(var.name(), round(var.solution_value(), params["DIGITS_ON_SOLUTION"])))
    elif(status == solver.UNBOUNDED):
        print('The problem is unbounded!')
    else:
        print('No solution found!')

def build_Gurobipy_model(A, b, c, n, var_range, row_range, leq_constraints, 
geq_constraints, var_type, obj_type, ub_inputs, lb_inputs, params):
    if(params["MEMORY_LIMIT"]):
        env = gp.Env(empty=True)
        env.setParam("MemLimit", params["MEMORY_LIMIT"])
        env.start()
        solver = gp.Model(env=env)
    else:
        solver = gp.Model()
    infinity = float('INF')

    # Processing the upper and lower bounds using the OR-Tools infinity:
    if(isinstance(ub_inputs, np.ndarray)):
        if(len(ub_inputs) != n):
            raise RuntimeError('Shape of ub array is incompatible with problem size!')
    elif(isinstance(ub_inputs, float)):
        ub_inputs = np.full(n, ub_inputs)
    else:
        ub_inputs = np.full(n, infinity)

    if(isinstance(lb_inputs, np.ndarray)):
        if(len(lb_inputs) != n):
            raise RuntimeError('Shape of lb array is incompatible with problem size!')
    elif(isinstance(lb_inputs, float)):
        lb_inputs = np.full(n, lb_inputs)
    else:
        lb_inputs = np.full(n, 0.0)

    # Creating the variables:
    x = dict()
    for j in var_range:
        if(var_type[j] == 'real'):
            x[j] = solver.addVar(lb=lb_inputs[j-1], ub=ub_inputs[j-1], name='x[{}]'.format(j))
        elif(var_type[j] == 'binary'):
            x[j] = solver.addVar(vtype=gp.GRB.BINARY, name='x[{}]'.format(j))
        else:
            x[j] = solver.addVar(vtype=gp.GRB.INTEGER, lb=lb_inputs[j-1], ub=ub_inputs[j-1], name='x[{}]'.format(j))

    # Objective Function
    if(obj_type == '*EMPTY*'):
        obj_type = 'min'
    if(obj_type == 'min'):
        obj = solver.setObjective(gp.quicksum(c[j] * x[j] for j in var_range), sense=gp.GRB.MINIMIZE)
    elif(obj_type == 'max'):
        obj = solver.setObjective(gp.quicksum(c[j] * x[j] for j in var_range), sense=gp.GRB.MAXIMIZE)
    else:
        raise RuntimeError('Problem in the objective function type input!')

    # Adding the constraints sets:
    cstr = dict()
    if(leq_constraints == '*'):
        cstr.update({'leq_{}'.format(i): solver.addConstr(
            gp.quicksum(A[i, j] * x[j] for j in var_range) <= b[i]) for i in row_range}
        )
    else:
        cstr.update({'leq_{}'.format(i): solver.addConstr(
            gp.quicksum(A[i, j] * x[j] for j in var_range) <= b[i]) for i in leq_constraints}
        )
    if(geq_constraints == '*'):
        cstr.update({'leq_{}'.format(i): solver.addConstr(
            gp.quicksum(A[i, j] * x[j] for j in var_range) >= b[i]) for i in row_range}
        )
    else:
        cstr.update({'leq_{}'.format(i): solver.addConstr(
            gp.quicksum(A[i, j] * x[j] for j in var_range) >= b[i]) for i in geq_constraints}
        )
    if(leq_constraints != '*' and geq_constraints != '*'):
        eq_constraints = set(row_range).difference(set(leq_constraints).union(set(geq_constraints)))
        cstr.update({'leq_{}'.format(i): solver.addConstr(
            gp.quicksum(A[i, j] * x[j] for j in var_range) == b[i]) for i in eq_constraints}
        )

    return solver, x, obj, cstr

def solve_Gurobipy_model(solver, params):
    # Solving the problem and printing results:
    if(params["TOTAL_SOLVING_TIME"] > 0):
        solver.setParam('TimeLimit', params["TOTAL_SOLVING_TIME"])
    if(params["PRINT_SOLUTION_LOG"]):
        solver.setParam('LogToConsole', 1)
    else:
        solver.setParam('LogToConsole', 0)
    solver.setParam('Threads', params["NUM_THREADS"])
    if(params["RELATIVE_MIP_GAP_VALUE"] > 0):
        solver.setParam('MIPGap', params["RELATIVE_MIP_GAP_VALUE"])
    if(params["NODEFILE_START_SIZE"]):
        solver.setParam("NodefileStart", params["NODEFILE_START_SIZE"])
    solver.optimize()

    return solver.Status

def print_Gurobipy_solution(solver, status, params):
    print('Variables defined: [ ')
    print('    ', end='')
    for var in solver.getVars():
        print(f'{var.VarName}', end=' ')
    print('\n]')

    if(solver.ModelSense == gp.GRB.MINIMIZE):
        obj_type = 'MIN'
    elif(solver.ModelSense == gp.GRB.MAXIMIZE):
        obj_type = 'MAX'
    else:
        raise RuntimeError('Problem in printing the objective function type!')

    print('Objective function being considered: {}'.format(obj_type.upper()))
    if((status == gp.GRB.SUBOPTIMAL) or (status == gp.GRB.OPTIMAL)):
        ObjVal = solver.ObjVal
        print('Objective found with value: {}'.format(round(ObjVal, params["DIGITS_ON_SOLUTION"])))
        if(status == gp.GRB.SUBOPTIMAL):
            print('The solution found is FEASIBLE!')
        else:
            print('The solution found is OPTIMAL!')
        print('Variables values:')
        if(params["PRINT_ZERO_VARS"]):
            for var in solver.getVars():
                print('{} = {}'.format(var.VarName, round(var.X, params["DIGITS_ON_SOLUTION"])))
        else:
            for var in solver.getVars():
                if(var.X != 0):
                    print('{} = {}'.format(var.VarName, round(var.X, params["DIGITS_ON_SOLUTION"])))
    elif(status == gp.GRB.UNBOUNDED):
        print('The problem is unbounded!')
    else:
        print('No solution found!')

    return status

def build_Python_MIP_model(A, b, c, n, var_range, row_range, leq_constraints, 
geq_constraints, var_type, obj_type, ub_inputs, lb_inputs, params):
    # Processing objective type:
    if(obj_type == '*EMPTY*'):
        obj_type = 'min'
    if(obj_type == 'min'):
        model_sense = mip.MINIMIZE
    elif(obj_type == 'max'):
        model_sense = mip.MAXIMIZE
    else:
        raise RuntimeError('Problem in the objective function type input!')

    # Setting up the selected optimization solver:
    if(params["SOLVER_NAME"].upper()=="CBC"):
        solver = mip.Model(solver_name=mip.CBC, sense=model_sense)
    elif(params["SOLVER_NAME"].upper()=="GUROBI"):
        solver = mip.Model(solver_name=mip.GUROBI, sense=model_sense)
    else:
        raise NameError('Invalid Solver name!')

    infinity = mip.INF

    # Processing the upper and lower bounds using the OR-Tools infinity:
    if(isinstance(ub_inputs, np.ndarray)):
        if(len(ub_inputs) != n):
            raise RuntimeError('Shape of ub array is incompatible with problem size!')
    elif(isinstance(ub_inputs, float)):
        ub_inputs = np.full(n, ub_inputs)
    else:
        ub_inputs = np.full(n, infinity)

    if(isinstance(lb_inputs, np.ndarray)):
        if(len(lb_inputs) != n):
            raise RuntimeError('Shape of lb array is incompatible with problem size!')
    elif(isinstance(lb_inputs, float)):
        lb_inputs = np.full(n, lb_inputs)
    else:
        lb_inputs = np.full(n, 0.0)

    # Creating the variables:
    x = dict()
    for j in var_range:
        if(var_type[j] == 'real'):
            x[j] = solver.add_var(lb=lb_inputs[j-1], ub=ub_inputs[j-1], name='x[{}]'.format(j))
        elif(var_type[j] == 'binary'):
            x[j] = solver.add_var(var_type=mip.BINARY, name='x[{}]'.format(j))
        else:
            x[j] = solver.add_var(var_type=mip.INTEGER, lb=lb_inputs[j-1], ub=ub_inputs[j-1], name='x[{}]'.format(j))

    # Objective Function
    solver.objective = mip.xsum(c[j] * x[j] for j in var_range)
    obj = solver.objective

    # Adding the constraints sets:
    cstr = dict()
    if(leq_constraints == '*'):
        for i in row_range:
            solver += mip.xsum(A[i, j] * x[j] for j in var_range) <= b[i]
    else:
        for i in leq_constraints:
            solver += mip.xsum(A[i, j] * x[j] for j in var_range) <= b[i]

    if(geq_constraints == '*'):
        for i in row_range:
            solver += mip.xsum(A[i, j] * x[j] for j in var_range) >= b[i]
    else:
        for i in geq_constraints:
            solver += mip.xsum(A[i, j] * x[j] for j in var_range) >= b[i]

    if(leq_constraints != '*' and geq_constraints != '*'):
        eq_constraints = set(row_range).difference(set(leq_constraints).union(set(geq_constraints)))
        for i in eq_constraints:
            solver += mip.xsum(A[i, j] * x[j] for j in var_range) == b[i]

    return solver, x, obj, cstr

def solve_Python_MIP_model(solver, params):
    # Solving the problem and printing results:
    if(params["TOTAL_SOLVING_TIME"] > 0):
        solver.max_seconds = params["TOTAL_SOLVING_TIME"]
    if(params["PRINT_SOLUTION_LOG"]):
        solver.verbose = 1
    else:
        solver.verbose = 0
    if(params["CHECK_CLIQUE_MERGE"]):
        solver.clique_merge()
    solver.threads = params["NUM_THREADS"]
    if(params["RELATIVE_MIP_GAP_VALUE"] > 0):
        solver.max_mip_gap = params["RELATIVE_MIP_GAP_VALUE"]
    status = solver.optimize()

    return status

def print_Python_MIP_solution(solver, status, params):
    print('Variables defined: [ ')
    print('    ', end='')
    for var in solver.vars:
        print(f'{var.name}', end=' ')
    print('\n]')

    obj_type = solver.sense

    print('Objective function being considered: {}'.format(obj_type.upper()))

    if((status == mip.OptimizationStatus.FEASIBLE) or (status == mip.OptimizationStatus.OPTIMAL)):
        ObjVal = solver.objective_value
        print('Objective found with value: {}'.format(round(ObjVal, params["DIGITS_ON_SOLUTION"])))
        if(status == mip.OptimizationStatus.FEASIBLE):
            print('The solution found is FEASIBLE!')
        else:
            print('The solution found is OPTIMAL!')
        print('Variables values:')
        if(params["PRINT_ZERO_VARS"]):
            for var in solver.vars:
                print('{} = {}'.format(var.name, round(var.x, params["DIGITS_ON_SOLUTION"])))
        else:
            for var in solver.vars:
                if(var.x != 0):
                    print('{} = {}'.format(var.name, round(var.x, params["DIGITS_ON_SOLUTION"])))
    elif(status == mip.OptimizationStatus.UNBOUNDED):
        print('The problem is unbounded!')
    else:
        print('No solution found!')

    return status

def build_empty_parameters():
    leq_constraints = '*EMPTY*'
    geq_constraints = '*EMPTY*'
    bin_vars = '*EMPTY*'
    int_vars = '*EMPTY*'
    obj_type = '*EMPTY*'
    ub_inputs = '*EMPTY*'
    lb_inputs = '*EMPTY*'

    return obj_type, leq_constraints, geq_constraints, bin_vars, int_vars, lb_inputs, ub_inputs

def process_matrix_input_data(INPUT_FILE_PATH):
    c = list()
    b = list()
    A = list()
    obj_type, leq_constraints, geq_constraints, bin_vars, int_vars, lb_inputs, ub_inputs = build_empty_parameters()

    # Function to read the "bin", "int", "leq" and "geq" inputs:
    def read_range_friendly_input_format(input_line):
        if(line[-1] == '*'):
            values = '*'
            return values
        values = list()
        aux_vals_list = re.search('=([ 0-9\-\,]+)$', line).group(1)
        aux_vals_list = aux_vals_list.strip().split(',')
        for entry in aux_vals_list:
            if('-' in entry):
                val1, val2 = entry.split('-')
                val1 = int(val1.strip())
                val2 = int(val2.strip())
                values.extend(list(range(val1, val2+1)))
            else:
                values.append(int(entry.strip()))
        return values

    # Function to read the "ub" and "lb" values
    def read_number_or_array_input_format(input_line):
        try:
            values = float(re.search('=([ 0-9\.\-]+)$', line).group(1))
        except:
            values = re.search('=([ 0-9\,\.\-]+)$', line).group(1)
            values = values.strip().split(',')
            values = np.array(values, dtype=float)
        return values

    present_A_line = 0
    scanning_A_matrix = False
    with open(INPUT_FILE_PATH) as file:
        for raw_line in file:
            line = raw_line.strip()

            # If the reader is processing the lines of the A matrix:
            if(scanning_A_matrix):
                present_A_line += 1
                if(not line[-1] in '];'):
                    raise RuntimeError('The A matrix lines must end with ] or ;')
                A.append(list(map(float, line[:-1].split(','))))
                if(line[-1] == ';'):
                    continue
                elif(line[-1] == ']'):
                    scanning_A_matrix = False
                else:
                    raise RuntimeError('Did not find ; at the of line {} of A matrix'.format(present_A_line))

            # Reading the b = [...] line:
            if(re.search('^b[ ]*=[ ]*\[', line)):
                start_point = line.find('[')
                if((line[-1] != ']') or (start_point == -1)):
                    raise RuntimeError('Input b must be in the format: b = [val_1, val_2, ..., val_m]')
                b = np.array(list(map(float, line[start_point+1:-1].split(','))))
                continue

            # Reading the c = [...] line:
            if(re.search('^c[ ]*=[ ]*\[', line)):
                start_point = line.find('[')
                if((line[-1] != ']') or (start_point == -1)):
                    raise RuntimeError('Input c must be in the format: c = [val_1, val_2, ..., val_n]')
                c = np.array(list(map(float, line[start_point+1:-1].split(','))))
                continue

            # Reading the first line of the A matrix:
            if(re.search('^A[ ]*=[ ]*\[', line)):
                present_A_line = 1
                start_point = line.find('[')
                if(start_point == -1):
                    raise RuntimeError('Did not find the left square brackets [ while scanning the A matrix')
                if(not line[-1] in '];'):
                    raise RuntimeError('The A matrix lines must end with ] or ;')
                A.append(list(map(float, line[start_point+1:-1].split(','))))
                if(line[-1] == ']'):
                    scanning_A_matrix = False
                else:
                    scanning_A_matrix = True
            
            # Reading the obj input line:
            if(re.search('^obj[ ]*=[ ]*', line)):
                aux_obj_type = re.search('=(.*)$', line).group(1)
                obj_type = aux_obj_type.strip().lower()
                if((obj_type != 'min') and (obj_type != 'max')):
                    raise RuntimeError('Problem with the objective function specified!')

            # Reading the leq input line:
            if(re.search('^leq[ ]*=[ ]*', line)):
                leq_constraints = read_range_friendly_input_format(line)
                continue

            # Reading the geq input line:
            if(re.search('^geq[ ]*=[ ]*', line)):
                geq_constraints = read_range_friendly_input_format(line)
                continue

            # Reading the ub input line:
            if(re.search('^ub[ ]*=[ ]*', line)):
                ub_inputs = read_number_or_array_input_format(line)
                continue

            # Reading the lb input line:
            if(re.search('^lb[ ]*=[ ]*', line)):
                lb_inputs = read_number_or_array_input_format(line)
                continue

            # Reading the bin input line:
            if(re.search('^bin[ ]*=[ ]*', line)):
                bin_vars = read_range_friendly_input_format(line)
                continue

            # Reading the int input line:
            if(re.search('^int[ ]*=[ ]*', line)):
                int_vars = read_range_friendly_input_format(line)
                continue

    c = np.array(c, dtype=float)
    b = np.array(b, dtype=float)
    A = np.array(A, dtype=float)

    return c, b, A, obj_type, leq_constraints, geq_constraints, bin_vars, int_vars, lb_inputs, ub_inputs

def process_json_input_data(INPUT_FILE_PATH):
    with open(INPUT_FILE_PATH) as file:
        data_json = json.load(file)
    b = np.array(data_json['b'], dtype=float)
    c = np.array(data_json['c'], dtype=float)
    A = np.array(data_json['A'], dtype=float)
    obj_type, leq_constraints, geq_constraints, bin_vars, int_vars, lb_inputs, ub_inputs = build_empty_parameters()
    if('obj' in data_json.keys()):
        obj_type = data_json['obj']
    if('leq' in data_json.keys()):
        if(data_json['leq'] == [-1]):
            leq_constraints = '*'
        else:
            leq_constraints = data_json['leq']
    if('geq' in data_json.keys()):
        if(data_json['geq'] == [-1]):
            geq_constraints = '*'
        else:
            geq_constraints = data_json['geq']
    if('bin' in data_json.keys()):
        if(data_json['bin'] == [-1]):
            bin_vars = '*'
        else:
            bin_vars = data_json['bin']
    if('int' in data_json.keys()):
        if(data_json['int'] == [-1]):
            int_vars = '*'
        else:
            int_vars = data_json['int']
    if('ub' in data_json.keys()):
        ub_inputs = data_json['ub']
    if('lb' in data_json.keys()):
        lb_inputs = data_json['lb']
    return c, b, A, obj_type, leq_constraints, geq_constraints, bin_vars, int_vars, lb_inputs, ub_inputs

def process_mps_or_lp_input_model(params):
    if(params["MODELING_LANGUAGE_NAME"] == "PYTHON-MIP"):
        # Setting up the selected optimization solver:
        if(params["SOLVER_NAME"].upper()=="CBC"):
            solver = mip.Model(solver_name=mip.CBC)
        elif(params["SOLVER_NAME"].upper()=="GUROBI"):
            solver = mip.Model(solver_name=mip.GUROBI)
        else:
            raise NameError('Invalid Solver name!')
        solver.read(params["INPUT_FILE_PATH"])
    elif(params["MODELING_LANGUAGE_NAME"] == "GUROBIPY"):
        solver = gp.read(params["INPUT_FILE_PATH"])
    else:
        if(params["INPUT_TYPE"] == 'mps'):
            raise RuntimeError('Problem reading MPS input file!')
        elif(params["INPUT_TYPE"] == 'lp'):
            raise RuntimeError('Problem reading LP input file!')
        else:
            raise RuntimeError('Unknown problem while reading the input file!')
    return solver

def validate_and_build_solving_parameters(A, b, c, obj_type, bin_vars, int_vars, leq_constraints, geq_constraints):
    #Validating shapes:
    if(len(b) != A.shape[0]):
        raise RuntimeError('Shapes of b and A are incompatible!')

    if(len(c) != A.shape[1]):
        raise RuntimeError('Shapes of c and A are incompatible!')

    # Building auxiliary size parameters:
    m = A.shape[0]
    n = A.shape[1]
    var_range = range(1, n+1)
    row_range = range(1, m+1)

    # Input parameters changed into dictionaries:
    A = {((i+1), (j+1)) : A[i][j] for i in range(len(A)) for j in range(len(A[i]))}
    b = {(j+1) : b[j] for j in range(len(b))}
    c = {(j+1) : c[j] for j in range(len(c))}

    # Setting up the variables types:
    var_type = {j: 'real' for j in var_range}

    if(bin_vars != '*EMPTY*'):
        if(bin_vars == '*'):
            var_type = {j: 'binary' for j in var_range}
        else:
            var_type.update({j: 'binary' for j in bin_vars})
    if(int_vars != '*EMPTY*'):
        if(int_vars == '*'):
            var_type = {j: 'int' for j in var_range}
        else:
            var_type.update({j: 'int' for j in int_vars})

    # Validating leq and geq constraints:
    if(leq_constraints == '*EMPTY*'):
        leq_constraints = []
    if(geq_constraints == '*EMPTY*'):
        geq_constraints = []

    if(obj_type == '*EMPTY*'):
        obj_type = 'min'

    return A, b, c, m, n, obj_type, var_range, row_range, var_type, leq_constraints, geq_constraints

def print_help_with_solvers_message():
    print('*****')
    print("Solve_LP uses the OR-Tools module from Google as modeling language, and so it offers support to different linear optimization solvers.")
    print("Here we show a brief description of this support, based on the documentation made available by the OR-Tools developers.")
    print("For more information please refer to the solvers/or-tools documentations.")
    print()
    print('*) BOP: Boolean/Integer Problems solver developed by Google. A free option to face IP problems. It is recommended to always set a maximum solution time when using BOP!')
    print('*) CBC: COIN_OR Branch-and-Cut solver. It is a general purpose open-source MILP solver from COIN-OR.')
    print('*) CLP: COIN-OR Linear Programming Solver. It is an open-source LP solver from COIN-OR.')
    print('*) CPLEX: A solver developed by IBM that can be used to tackle MILP problems. It is a proprietary solver, and so users need to have a license to use.')
    print('*) GLOP: Google Linear Optimization Problems solver. Developed to solve only LP problems, it is an open source project made available by Google since 2014.')
    print('*) GLPK: GNU Linear Programming Kit. Requires user license. Free?')
    print('*) GUROBI: A solver developed by the Gurobi Optimization group that can be used to tackle MILP problems. It is a proprietary solver, and so users need to have a license to use.')
    print('*) PDLP: Google First Order LP solver (...)')
    print('*) SAT: A free option to solver IP problems (It is the Google Constraints Programming SAT-Based solver?)')
    print('*) SCIP: Solving Constraint Integer Programs. A non-commercial solver that can be used to solve general MILP models.')
    print('*) XPRESS:A solver developed by the FICO group that can be used to tackle MILP problems. It is a proprietary solver, and so users need to have a license to use.')
    print('Where...')
    print('BP = Binary Programming (only binary variables);')
    print('IP = Integer Programming (integer and/or binary variables)')
    print('LP = Linear Programming (only real variables)')
    print('MILP = Mixed Integer Linear Programming (real and integer/binary variables).')
    print()
    print('General notes:')
    print('-) Proprietary solvers may have problems to find the license file of the user. Please refer to the OR-Tools documentation to find help setting environment variables to use these solvers;')
    print('-) MILP solvers may be used to solve LP problems without any difference in the user inputs.')
    print('*****')

def build_arg_parser():
    parser = argparse.ArgumentParser(prog='solve_lp', 
        allow_abbrev=False,
        description = '''Solve_lp is a CLI used to solve linear programming problems in a simple way.''',
        epilog='''***This is a Python3 script built with educational purposes, and so it is not intended to be used
        in large production environments.***
        
        More informations can be found at https://github.com/Eduardo281/solve_lp.'''
    )

    parser.add_argument('-f', '--file', nargs=1, metavar="INPUT_FILE_PATH", type=str,
        default=None, help= 'Path to the data file to be used')
    parser.add_argument('-t', '--time', nargs = 1, metavar = "TOTAL_SOLVING_TIME", type = int,
        default=None, help = "Total allowed time for the solver to work (in seconds).")
    parser.add_argument('-g', '--gap', nargs = 1, metavar = "REL_MIP_GAP_VALUE", type = float,
        default=None, help = "Relative MIP GAP value to be considered.")
    parser.add_argument('-s', '--solver', nargs = 1, metavar = "SOLVER_NAME", type = str,
        default=None, help = "Which solver to use in the solution procedure. Remember that not all solvers can solve Integer/Mixed Integer problems!")
    parser.add_argument('-d', '--digits', nargs = 1, metavar = "DIGITS_ON_SOLUTION", type = int,
        default=None, help = "How many digits to be considered in the final solution display.")
    parser.add_argument('-r', '--threads', nargs = 1, metavar='NUM_THREADS', type=int,
        default=None, help = 'Number of threads to be used by the solver')
    parser.add_argument('--memory-limit', nargs = 1, metavar='MEMORY_LIMIT_IN_GB', type=int,
        dest='memory_limit', default=None, help = '(only available using gurobipy)')
    parser.add_argument('--nodefile-start-size', nargs = 1, metavar='NODEFILE_START_SIZE_IN_GB', type=int,
        dest='nodefile_start_size', default=None, help = '(only available on gurobipy)')
    parser.add_argument('-m', '--modeling-language', nargs=1, metavar='MODELING_LANGUAGE', type=str,
        default=None, dest='modeling_language', 
        help = 'Which modeling language to use. Available: GUROBIPY, OR-TOOLS and PYTHON-MIP.')
    parser.add_argument('--help-with-solvers', action='store_true', default=None, 
        dest='PRINT_HELP_WITH_SOLVERS', help='Prints out a detailed description of the available solvers.')

    zeros_meg_parser = parser.add_mutually_exclusive_group(required=False)
    zeros_meg_parser.add_argument('--zeros', dest='zeros', action='store_true')
    zeros_meg_parser.add_argument('--no-zeros', dest='zeros', action='store_false')
    zeros_meg_parser.set_defaults(zeros=False)

    log_meg_parser = parser.add_mutually_exclusive_group(required=False)
    log_meg_parser.add_argument('--log', dest='log', action='store_true')
    log_meg_parser.add_argument('--no-log', dest='log', action='store_false')
    log_meg_parser.set_defaults(log=False)

    verbose_meg_parser = parser.add_mutually_exclusive_group(required=False)
    verbose_meg_parser.add_argument('--verbose', dest='verbose', action='store_true')
    verbose_meg_parser.add_argument('--no-verbose', dest='verbose', action='store_false')
    verbose_meg_parser.set_defaults(verbose=False)

    verbose_meg_parser = parser.add_mutually_exclusive_group(required=False)
    verbose_meg_parser.add_argument('--check_clique_merge', dest='clique_merge', action='store_true')
    verbose_meg_parser.add_argument('--no-check_clique_merge', dest='clique_merge', action='store_false')
    verbose_meg_parser.set_defaults(clique_merge=False)

    input_type_meg_parser = parser.add_mutually_exclusive_group(required=False)
    input_type_meg_parser.add_argument('--matrix-input', dest='input_type', action='store_const', const='matrix')
    input_type_meg_parser.add_argument('--mps-input', dest='input_type', action='store_const', const='mps')
    input_type_meg_parser.add_argument('--json-input', dest='input_type', action='store_const', const='json')
    input_type_meg_parser.add_argument('--lp-input', dest='input_type', action='store_const', const='lp')
    input_type_meg_parser.set_defaults(input_type=None)

    return parser

def process_args_from_parser(args, default_arguments):
    INPUT_FILE_PATH = args.file[0]

    if(args.input_type):
        INPUT_TYPE = args.input_type
    else:
        INPUT_TYPE = default_arguments["DEFAULT_INPUT_TYPE"]

    PRINT_ZERO_VARS = args.zeros
    PRINT_SOLUTION_LOG = args.log
    VERBOSE_PRINT = args.verbose
    CHECK_CLIQUE_MERGE = args.clique_merge

    if(args.time):
        TOTAL_SOLVING_TIME = args.time[0]
    else:
        TOTAL_SOLVING_TIME = default_arguments["DEFAULT_SOLVING_TIME"]
    
    if(args.digits):
        DIGITS_ON_SOLUTION = args.digits[0]
    else:
        DIGITS_ON_SOLUTION = default_arguments["DEFAULT_DIGITS_ON_SOLUTION"]

    if(args.modeling_language):
        if(args.modeling_language[0].upper() not in default_arguments["ACCEPTED_MODELING_LANGUAGES"]):
            print('The modeling languages available are:')
            print(default_arguments["ACCEPTED_MODELING_LANGUAGES"])
            print('Input received was: {}'.format(args.modeling_language[0]))
            raise ValueError('Did not find solver with the specified name!')
        MODELING_LANGUAGE_NAME = args.modeling_language[0].upper()
    else:
        if(INPUT_TYPE in ['matrix', 'json']):
            MODELING_LANGUAGE_NAME = default_arguments["DEFAULT_MODELING_LANGUAGE_MAT_JSON"]
        elif(INPUT_TYPE in ['mps', 'lp']):
            MODELING_LANGUAGE_NAME = default_arguments["DEFAULT_MODELING_LANGUAGE_LP_MPS"]

    if(args.solver):
        if(args.solver[0].upper() not in default_arguments["ACCEPTED_SOLVERS"]):
            print('The solvers available are:')
            print(default_arguments["ACCEPTED_SOLVERS"])
            print('Input received was: {}'.format(args.solver[0]))
            raise ValueError('Did not find solver with the specified name!')
        SOLVER_NAME = args.solver[0]
    else:
        if(MODELING_LANGUAGE_NAME == 'OR-TOOLS'):
            SOLVER_NAME = default_arguments["DEFAULT_OR_TOOLS_SOLVER"]
        elif(MODELING_LANGUAGE_NAME == 'PYTHON-MIP'):
            SOLVER_NAME = default_arguments["DEFAULT_PYTHON_MIP_SOLVER"]
        elif(MODELING_LANGUAGE_NAME == 'GUROBIPY'):
            SOLVER_NAME = 'GUROBI'
        else:
            raise RuntimeError('Problem processing the selected modeling language!')

    if(args.threads):
        NUM_THREADS = args.threads[0]
    else:
        NUM_THREADS = default_arguments["DEFAULT_NUM_THREADS"]

    if(args.gap):
        RELATIVE_MIP_GAP_VALUE = args.gap[0]
    else:
        RELATIVE_MIP_GAP_VALUE = default_arguments["DEFAULT_MIP_GAP"]

    if(args.memory_limit):
        MEMORY_LIMIT = args.memory_limit[0]
    else:
        MEMORY_LIMIT = None

    if(args.nodefile_start_size):
        NODEFILE_START_SIZE = args.nodefile_start_size[0]
    else:
        NODEFILE_START_SIZE = None

    params = {
        "INPUT_FILE_PATH": INPUT_FILE_PATH,
        "INPUT_TYPE": INPUT_TYPE,
        "PRINT_ZERO_VARS": PRINT_ZERO_VARS,
        "PRINT_SOLUTION_LOG": PRINT_SOLUTION_LOG,
        "VERBOSE_PRINT": VERBOSE_PRINT,
        "CHECK_CLIQUE_MERGE": CHECK_CLIQUE_MERGE,
        "TOTAL_SOLVING_TIME": TOTAL_SOLVING_TIME,
        "DIGITS_ON_SOLUTION": DIGITS_ON_SOLUTION,
        "MODELING_LANGUAGE_NAME": MODELING_LANGUAGE_NAME,
        "SOLVER_NAME": SOLVER_NAME,
        "NUM_THREADS": NUM_THREADS,
        "RELATIVE_MIP_GAP_VALUE": RELATIVE_MIP_GAP_VALUE,
        "MEMORY_LIMIT": MEMORY_LIMIT,
        "NODEFILE_START_SIZE": NODEFILE_START_SIZE
    }

    return params

def main():
    # Default solve_lp parameters:
    default_arguments = {
        "ACCEPTED_SOLVERS": ['BOP', 'CBC', 'CLP', 'CPLEX', 'GLOP', 'GLPK', 'GUROBI', 'PDLP', 'SAT', 'SCIP', 'XPRESS'],
        "ACCEPTED_MODELING_LANGUAGES": ['GUROBIPY', 'OR-TOOLS', 'PYTHON-MIP'],
        "DEFAULT_MODELING_LANGUAGE_MAT_JSON": 'OR-TOOLS',
        "DEFAULT_MODELING_LANGUAGE_LP_MPS": 'PYTHON-MIP',
        "DEFAULT_OR_TOOLS_SOLVER": 'SCIP',
        "DEFAULT_PYTHON_MIP_SOLVER": 'CBC',
        "DEFAULT_SOLVING_TIME":  30,
        "DEFAULT_DIGITS_ON_SOLUTION":  5,
        "DEFAULT_NUM_THREADS": 1,
        "DEFAULT_MIP_GAP": 10**(-5),
        "DEFAULT_INPUT_TYPE": 'matrix'
    }

    # Building the argument parser:
    parser = build_arg_parser()

    # Retrieving data from the argument parser:
    args = parser.parse_args()

    # When printing the "help from solvers" option, the system will exit after:
    if(args.PRINT_HELP_WITH_SOLVERS):
        print_help_with_solvers_message()
        sys.exit(100)

    # If no input file is passed, it will raise an error:
    if(not args.file):
        raise RuntimeError('The following argument is required: -f/--file')

    # Setting up the solver configs:
    params = process_args_from_parser(args, default_arguments)

    # Verbose mode information printing
    if(params["VERBOSE_PRINT"]):
        print('Solve_LP started!')
        print()
        print('Reading input data file...')

    if(params["INPUT_TYPE"] in ['matrix', 'json']):
        # Reading the input data:
        if(params["INPUT_TYPE"] == 'json'):
            (c, b, A, obj_type, leq_constraints, geq_constraints, 
            bin_vars, int_vars, lb_inputs, ub_inputs) = process_json_input_data(params["INPUT_FILE_PATH"])
        elif(params["INPUT_TYPE"] == 'matrix'):
            (c, b, A, obj_type, leq_constraints, geq_constraints, 
            bin_vars, int_vars, lb_inputs, ub_inputs) = process_matrix_input_data(params["INPUT_FILE_PATH"])    
        else:
            raise RuntimeError('Problem with the input type!')

        # Verbose mode information printing
        if(params["VERBOSE_PRINT"]):
            print('Data file was read!')
            print()
            print('Starting to instantiate the inputed solver ({})...'.format(params["SOLVER_NAME"].upper()))
            print()

        # Creating the optimization model and the variables:
        print('b:')
        print(b)
        print('c:')
        print(c)
        print('A:')
        print(A)
        print('leq:')
        print(leq_constraints)
        print('geq:')
        print(geq_constraints)
        print('bin:')
        print(bin_vars)
        print('int:')
        print(int_vars)
        print('obj_type:' + obj_type + "\n")
        print('ub_inputs:')
        print(ub_inputs)
        print('lb_inputs:')
        print(lb_inputs)

        # Verbose mode information printing
        if(params["VERBOSE_PRINT"]):
            print('Validating data and starting to build the model...')

        # Last data processing before build the solver:
        (A, b, c, m, n, obj_type, var_range, row_range, var_type, 
        leq_constraints, geq_constraints) = validate_and_build_solving_parameters(
            A, b, c, obj_type, bin_vars, int_vars, leq_constraints, geq_constraints
        )

        if(params["MODELING_LANGUAGE_NAME"] == 'OR-TOOLS'):
            # Solving the model using Google's OR-Tools with the selected solver
            solver, x, obj, cstr = build_OR_Tools_model(A, b, c, n, var_range, row_range, leq_constraints, 
                geq_constraints, var_type, obj_type, ub_inputs, lb_inputs, params)
            status = solve_OR_Tools_model(solver, params)
            print_OR_Tools_solution(solver, status, params)
        elif(params["MODELING_LANGUAGE_NAME"] == 'PYTHON-MIP'):
            # Solving the model using Python MIP with the selected solver
            solver, x, obj, cstr = build_Python_MIP_model(A, b, c, n, var_range, row_range, leq_constraints, 
                geq_constraints, var_type, obj_type, ub_inputs, lb_inputs, params)
            status = solve_Python_MIP_model(solver, params)
            print_Python_MIP_solution(solver, status, params)
        elif(params["MODELING_LANGUAGE_NAME"] == 'GUROBIPY'):
            # Solving the model using Gurobi with its own modeling language
            solver, x, obj, cstr = build_Gurobipy_model(A, b, c, n, var_range, row_range, leq_constraints, 
                geq_constraints, var_type, obj_type, ub_inputs, lb_inputs, params)
            status = solve_Gurobipy_model(solver, params)
            print_Gurobipy_solution(solver, status, params)
        else:
            raise RuntimeError('Problem processing the selected modeling language!')
    elif(params["INPUT_TYPE"] in ['mps', 'lp']):
        solver = process_mps_or_lp_input_model(params)
        if(params["MODELING_LANGUAGE_NAME"] == 'OR-TOOLS'):
            pass
        if(params["MODELING_LANGUAGE_NAME"] == 'PYTHON-MIP'):
            status = solve_Python_MIP_model(solver, params)
            print_Python_MIP_solution(solver, status, params)
        if(params["MODELING_LANGUAGE_NAME"] == 'GUROBIPY'):
            status = solve_Gurobipy_model(solver, params)
            print_Gurobipy_solution(solver, status, params)

    print('END OF FILE!')

if __name__ == "__main__":
    main()
