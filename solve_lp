#!/usr/bin/python3

# CLI ideas:
# -f --file: file name (REQUIRED)
# -t --time: solving time limit (OPTIONAL)
# -l --log: print solver solution log (OPTIONAL)
# -s --solver: which solver to be used (OPTIONAL)

from ortools.linear_solver import pywraplp
import numpy as np
import re

solver = pywraplp.Solver.CreateSolver('SCIP')
infinity = solver.infinity()

file_name = 'solve_lp_ex_mat_2'

c = list()
b = list()
A = list()
min_obj = True
present_A_line = 0
scanning_A_matrix = False
leq_constraints = '*EMPTY*'
bin_vars = '*EMPTY*'
int_vars = '*EMPTY*'
var_type = dict()
with open (file_name) as file:
    for raw_line in file:
        line = raw_line.strip()

        if(scanning_A_matrix):
            present_A_line += 1
            if(re.search('[+-] ', line)):
                raise RuntimeError('Isolated + or - signal find while reading line {} of A matrix!'.format(present_A_line))
            A.append([float(value) for value in re.findall('[+-]?[\d]+\.[\d]+|[+-]?[\d]+', line)])
            if(line[-1] == ';'):
                continue
            elif(line[-1] == ']'):
                scanning_A_matrix = False
            else:
                raise RuntimeError('Did not find ; at the of line {} of A matrix'.format(present_A_line))

        if(re.search('^b[ ]*=[ ]*\[', line)):
            if(re.search('[+-] ', line)):
                raise RuntimeError('Isolated + or - signal find while reading b vector!')
            b = [float(value) for value in re.findall('[+-]?[\d]+\.[\d]+|[+-]?[\d]+', line)]
        if(re.search('^c[ ]*=[ ]*\[', line)):
            if(re.search('[+-] ', line)):
                raise RuntimeError('Isolated + or - signal find while reading c vector!')
            c = [float(value) for value in re.findall('[+-]?[\d]+\.[\d]+|[+-]?[\d]+', line)]
        if(re.search('^A[ ]*=[ ]*\[', line)):
            present_A_line = 1
            if(re.search('[+-] ', line)):
                raise RuntimeError('Isolated + or - signal find while reading the 1st line of A matrix!')
            A.append([float(value) for value in re.findall('[+-]?[\d]+\.[\d]+|[+-]?[\d]+', line)])
            if(line[-1] == ']'):
                scanning_A_matrix = False
            else:
                scanning_A_matrix = True

        if(re.search('^leq[ ]*=[ ]*', line)):
            if(line[-1] == '*'):
                leq_constraints = '*'
                continue
            leq_constraints = int((re.search('[\d]+', line).group(0)))

        if(re.search('^min[ ]*=[ ]*', line)):
            if(re.search('False$', line)):
                min_obj = False
            else:
                min_obj = True

        if(re.search('^bin[ ]*=[ ]*', line)):
            if(line[-1] == '*'):
                bin_vars = '*'
                continue
            bin_vars = list()
            aux_bin_list = re.search('=([ 0-9\-\,]+)$', line).group(1)
            aux_bin_list = aux_bin_list.strip().split(',')
            for entry in aux_bin_list:
                if('-' in entry):
                    val1, val2 = entry.split('-')
                    val1 = int(val1.strip())
                    val2 = int(val2.strip())
                    bin_vars.extend(list(range(val1, val2+1)))
                else:
                    bin_vars.append(int(entry.strip()))
            continue

        if(re.search('^int[ ]*=[ ]*', line)):
            if(line[-1] == '*'):
                int_vars = '*'
                continue
            int_vars = list()
            aux_int_list = re.search('=([ 0-9\-\,]+)$', line).group(1)
            aux_int_list = aux_int_list.strip().split(',')
            for entry in aux_int_list:
                if('-' in entry):
                    val1, val2 = entry.split('-')
                    val1 = int(val1.strip())
                    val2 = int(val2.strip())
                    int_vars.extend(list(range(val1, val2+1)))
                else:
                    int_vars.append(int(entry.strip()))
            continue

print('b:')
print(b)
b = np.array(b)
print()
print('c:')
c = np.array(c)
print(c)
print()
A = np.array(A)
print('A:')
print(A)
print()
print('leq:')
print(leq_constraints)
print()
print('bin:')
print(bin_vars)
print()
print('int:')
print(int_vars)
print()

if(len(b) != A.shape[0]):
    raise RuntimeError('Shapes of b and A are incompatible!')

if(len(c) != A.shape[1]):
    raise RuntimeError('Shapes of c and A are incompatible!')

solver = pywraplp.Solver.CreateSolver('SCIP')
infinity = solver.infinity()
x = dict()

m = A.shape[0]
n = A.shape[1]

var_type = {j: 'real' for j in range(n)}

if(bin_vars != '*EMPTY*'):
    if(bin_vars == '*'):
        var_type = {j: 'bin' for j in range(n)}
    else:
        var_type.update({j: 'bin' for j in bin_vars})
if(int_vars != '*EMPTY*'):
    if(int_vars == '*'):
        var_type = {j: 'int' for j in range(n)}
    else:
        var_type.update({j: 'int' for j in int_vars})


for j in range(n):
    if(var_type[j] == 'real'):
        x[j] = solver.NumVar(0.0, infinity, 'x[{}]'.format(j))
    elif(var_type[j] == 'binary'):
        x[j] = solver.BoolVar('x[{}]'.format(j))
    else:
        x[j] = solver.IntVar(0, infinity, 'x[{}]'.format(j))

# Objective Function
if(min_obj):
    obj = solver.Minimize(
        sum(c[j] * x[j] for j in range(n))
    )
else:
    obj = solver.Maximize(
        sum(c[j] * x[j] for j in range(n))
    )

# Adding the constraints sets:
cstr = dict()
if(leq_constraints == '*'):
    for i in range(m):
        cstr[i] = solver.Add(
            sum(A[i, j] * x[j] for j in range(n)) <= b[i]
        )
else:
    for i in range(m):
        if(i <= leq_constraints-1):
            cstr[i] = solver.Add(
                sum(A[i, j] * x[j] for j in range(n)) <= b[i]
            )
        else:
            cstr[i] = solver.Add(
                sum(A[i, j] * x[j] for j in range(n)) == b[i]
            )

# Setting up the solver configs and solving the problem:
TOTAL_SOLVING_TIME = 30
PRINT_SOLUTION_LOG = False
NUM_THREADS = 1

if(TOTAL_SOLVING_TIME > 0):
    solver.set_time_limit(TOTAL_SOLVING_TIME * 1000)
if(PRINT_SOLUTION_LOG):
    solver.EnableOutput()
solver.SetNumThreads(NUM_THREADS)
status = solver.Solve()

# Printing results:
if((status == solver.FEASIBLE) or (status == solver.OPTIMAL)):
    ObjVal = solver.Objective().Value()
    print('Objective found with value: {}'.format(ObjVal))
    print('Variables values:')
    for j in range(n):
        print('x[{}] = {}'.format(j, round(x[j].solution_value(), 5)))
else:
    print('No solution found!')


print('END OF FILE!')
